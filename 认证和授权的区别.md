# 认证（Authentication）和授权（Authorization）

![流程图](./assets/%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83.jpg)

## 认证与授权的紧密耦合

认证在授权过程之前完成，授权过程在认证过程之后完成。二者长期被视为一个紧密耦合的概念。

* 由于对方是管理员，所以允许访问。
* 不允许访问，因为对方不是管理员。
* 如果允许访问，则对方是管理员。
* 如果不允许访问，则对方不是管理员。

## 认证（Authentication）

确认用户身份。其目的是验证用户身份的过程。如账号密码。认证发生在授权开始之前。

### 类型

#### 单因素认证（Single Factor Authentication，简称 SFA）

一个人匹配一个凭证，如：用户名密码。

* ***风险***：只要获取到账号密码，即可验证身份通过。存在被网站钓鱼攻击的风险

#### 双因素认证（简称 2FA）

两种因素来验证身份。双因素是多因素的子集，但实际上没什么不同。

#### 多因素认证（Multi Factor Authentication，简称 MFA）

使用三种及三种以上的因素来确认身份，能够在用户名称和密码之外再额外增加一层保护。如：短信/邮件验证码、指纹等多种组合方式。

通常是由至少两种不同因素组合：用户知道的东西（用户密码）、用户拥有的东西（OTP、TOTP等）、用户固有的东西（指纹、人脸等固有生物特征）。

***注意：*** 所有双因素认证都是多因素认证，但并非所有的MFA是2FA。

#### 单因素认证和多因素认证区

    |           单因素认证          |           多因素认证          |·
    |          :------:           |          :------:         |
    |   在单一的身份验证过程中，身份验证要简单得多   |   在多因素认证中，成功进行身份验证的过程可能很复杂   |
    |   存在安全风险   |   相较于更为安全   |
    |   信息有可能被盗   |   相较于更为安全   |
    |   无法完全控制   |   用户完全控制   |
    |   存在被网络钓鱼攻击的可能   |   多因素认证更为安全   |
    |   用户交互简单   |   用户交互较为繁琐复杂   |

### 认证方式

* 用户密码
* 手机和短信验证码
* 邮箱和邮箱验证码
* 图片和图形验证码
* 人脸识别、指纹识别等生物因素识别
* OTP（一次性密码）
* Radius网络

（以上仅简要列举方式，不展开论述，更多可自行了解）

#### OTP（One-time password）：一次性密码

##### 原理

通常分为两类：时间性和事件性。

##### TOTP（Time-based One-Time Password）：基于时间的一次性密码算法

时间同步。可设置密码有效时间，通常以30秒为间隔，从而避免反复尝试。

***python示例代码***

    ```
    import time
    import pyotp

    key = pyotp.random_base32()
    print(f'随机生成pyotp密钥，用于生成一次性密码：{key}')
    
    totp = pyotp.TOTP(key)
    codeTotp = totp.now()
    print(f'当前时间 TOTP：{codeTotp}')
    print(f'当前时间OTP是否为传入的OTP: {codeTotp} => {totp.verify(codeTotp)}')  # True
    time.sleep(10)
    print(f'当前时间OTP是否为传入的OTP：{codeTotp} => {totp.verify(codeTotp)}')  # True
    time.sleep(30)
    print(f'当前时间OTP是否为传入的OTP：{codeTotp} => {totp.verify(codeTotp)}')  # False
    ```

##### HOTP（HMAC-based One-Time Password）：基于HMAC算法加密的一次性密码

事件同步。指通过某一特定的事件次序及相同的种子值作为输入，通过HASH运算出一致的密码。不受时间限制。

***python示例代码***

    ```
    import time
    import pyotp

    key = pyotp.random_base32()
    print(f'随机生成pyotp密钥，用于生成一次性密码：{key}')
    
    hotp = pyotp.HOTP(key)
    print(f'当前计数器 HOTP：{hotp.at(0)}')
    print(f'当前计数器 HOTP：{hotp.at(10)}')
    print(f'当前计数器OTP是否为传入的OTP：{hotp.verify(hotp.at(10), 10)}')
    print(f'当前计数器OTP是否为传入的OTP：{hotp.verify(hotp.at(10), 20)}')
    ```

##### 适用场景

* 网银、网游的动态口令牌

##### 优点

* 密码只使用一次，且动态产生，难以预测
* 记忆与保存密码上的困难

##### 缺点

* 一次性密码多数需要一个受信任的系统来接收密码
* 收取方可能存在延迟或无法收取的情况

## 授权（Authorization）

授予对系统的访问权限。其目的是验证用户有权访问的过程。如数据库、系统资源等。授权发生在身份认证完成之后。

## 认证与授权的区别

|           验证          |           授权          |
|       :--------:       |       :--------:       |
|   在身份验证过程中，检查用户的身份以提供对系统的访问权限   |   在授权过程中，检查个人或用户的权限以访问资源   |
|   在认证过程中，用户或个人被验证   |   在此过程中，用户或个人得到验证   |
|   它在授权过程之前完成   |   虽然此过程是在身份验证过程之后完成的   |
|   它通常需要用户的登录详细信息   |   虽然它需要用户的特权或安全级别   |
|   身份验证确定此人是否为用户   |   虽然它决定了用户有什么权限？   |
|   对用户是可见的   |   对用户不可见   |
